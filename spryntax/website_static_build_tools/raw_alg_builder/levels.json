{"bubblesort":{"c":{"lines":"#include <stdlib.h>↵#include <stdio.h>↵↵int * create_int_list(const int size) {↵→if (size > 0) {↵→→return (int *) malloc(sizeof(int) * size);↵→}↵→return NULL;↵}↵↵void swap(int * int_list, const int index_other, const int index_chosen) {↵→int temporary = int_list[index_other];↵→int_list[index_other] = int_list[index_chosen];↵→int_list[index_chosen] = temporary;↵}↵↵void bubblesort(int * int_list, const int size) {↵→for (int index_chosen = 0; index_chosen < size; index_chosen++) {↵→→for (int index_other = index_chosen + 1; index_other < size; index_other++) {↵→→→if (int_list[index_other] < int_list[index_chosen]) {↵→→→→swap(int_list, index_other, index_chosen);↵→→→}↵→→}↵→}↵}↵↵int main() {↵→const int size = 5;↵→int * int_list = create_int_list(size);↵↵→int_list[0] = 6;↵→int_list[1] = -1;↵→int_list[2] = 5;↵→int_list[3] = 9;↵→int_list[4] = 1;↵↵→bubblesort(int_list, size);↵↵→free(int_list);↵}","comments":{"3":"/*\r * Memory allocation for the integer list.\r * In this case, we multiply \"sizeof(int)\" by 10 since we want an array with 10 integers!\r * \"(int *)\" is a cast just to ensure that we get a pointer to an integer from whatever malloc returns.\r */\r","4":"\t/* if the size the programmer passes is greater than 0, */\r","5":"\t\t/* \r\t\t * \"sizeof(int)\" returns the number of bytes an integer takes!\r\t\t * We can multiply this value by the programmer's specified size \r\t\t * to allocate a block of memory that's fitted just as they need!\r\t\t */\r","7":"\t/* if we're out here, the programmer gave us a size less than or equal to 0-- just return NULL! */\r","11":"\t/* in order to swap the values, we have to store one of the values elsewhere temporarily! */\r","12":"\t/* then we can move the chosen index's value to the other index! */\r","13":"\t/* ... and then move the old value of the other index into the chosen index! */\r","17":"\t/* \r\t * bubblesort focuses on doing this directly: we can choose an index and then look at the others.\r\t * When we \"choose\" an index, we can look at other indexes and ask the question: is the other index's \r\t * value less than the chosen index's value? If it is less, we can just swap them both!\r\t */\r","19":"\t\t\t/* \r\t\t\t * if the other index's value is less than the chosen index's value,\r\t\t\t * swap the values in the indexes!\r\t\t\t */\r","22":"\t\t\t/* ...and afterwards, continue on! keep going until you've checked every index! */\r","28":"\t/* create an integer array of size 5-- 5 indexes! */\r","30":"\t/* fill out the array... */\r","35":"\t/* int_list is currently: [6, -1, 5, 9, 1] */\r","36":"\t/* sort it from least to greatest via bubblesort! */\r","37":"\t/* int_list is now: [-1, 1, 5, 6, 9] */\r","38":"\t/* be sure to always free the memory you allocate! */\r"}},"py":{"lines":"def bubble_sort(arr):↵↵→for n in range(len(arr) - 1, 0, -1):↵↵→→swapped = False↵↵→→for i in range(n):↵→→→if arr[i] > arr[i + 1]:↵↵→→→→arr[i], arr[i + 1] = arr[i + 1], arr[i]↵↵→→→→swapped = True↵↵→→if not swapped:↵→→→break↵↵↵arr = [39, 12, 18, 85, 72, 10, 2, 18]↵print(\"Unsorted list is:\")↵print(arr)↵↵bubble_sort(arr)↵↵print(\"Sorted list is:\")↵print(arr)","comments":{"2":"\t# Outer loop to iterate through the list n times\r","4":"\t\t# Initialize swapped to track if any swaps occur\r","6":"\t\t# Inner loop to compare adjacent elements\r","9":"\t\t\t\t# Swap elements if they are in the wrong order\r","11":"\t\t\t\t# Mark that a swap has occurred\r","13":"\t\t# If no swaps occurred, the list is already sorted\r","17":"# Sample list to be sorted\r"}}},"mergesort":{"c":{"lines":"#include <stdio.h>↵#include <stdlib.h>↵↵void merge(int arr[], int l, int m, int r)↵{↵→int i, j, k;↵→int n1 = m - l + 1;↵→int n2 = r - m;↵↵→int L[n1], R[n2];↵↵→for (i = 0; i < n1; i++)↵→→L[i] = arr[l + i];↵→for (j = 0; j < n2; j++)↵→→R[j] = arr[m + 1 + j];↵↵→i = 0;↵→j = 0;↵→k = l;↵→while (i < n1 && j < n2) {↵→→if (L[i] <= R[j]) {↵→→→arr[k] = L[i];↵→→→i++;↵→→}↵→→else {↵→→→arr[k] = R[j];↵→→→j++;↵→→}↵→→k++;↵→}↵↵→while (i < n1) {↵→→arr[k] = L[i];↵→→i++;↵→→k++;↵→}↵↵→while (j < n2) {↵→→arr[k] = R[j];↵→→j++;↵→→k++;↵→}↵}↵↵void mergeSort(int arr[], int l, int r)↵{↵→if (l < r) {↵→→int m = l + (r - l) / 2;↵↵→→mergeSort(arr, l, m);↵→→mergeSort(arr, m + 1, r);↵↵→→merge(arr, l, m, r);↵→}↵}↵↵void printArray(int A[], int size)↵{↵→int i;↵→for (i = 0; i < size; i++)↵→→printf(\"%d \", A[i]);↵→printf(\"\\n\");↵}↵↵int main()↵{↵→int arr[] = { 12, 11, 13, 5, 6, 7 };↵→int arr_size = sizeof(arr) / sizeof(arr[0]);↵↵→printf(\"Given array is \\n\");↵→printArray(arr, arr_size);↵↵→mergeSort(arr, 0, arr_size - 1);↵↵→printf(\"\\nSorted array is \\n\");↵→printArray(arr, arr_size);↵→return 0;↵}","comments":{"0":"// C program for Merge Sort\r","3":"// Merges two subarrays of arr[].\r// First subarray is arr[l..m]\r// Second subarray is arr[m+1..r]\r","9":"\t// Create temp arrays\r","11":"\t// Copy data to temp arrays L[] and R[]\r","16":"\t// Merge the temp arrays back into arr[l..r\r","31":"\t// Copy the remaining elements of L[],\r\t// if there are any\r","37":"\t// Copy the remaining elements of R[],\r\t// if there are any\r","44":"// l is for left index and r is right index of the\r// sub-array of arr to be sorted\r","49":"\t\t// Sort first and second halves\r","56":"// Function to print an array\r","64":"// Driver code\r"}},"py":{"lines":"def merge(arr, left, mid, right):↵→n1 = mid - left + 1↵→n2 = right - mid↵↵→L = [0] * n1↵→R = [0] * n2↵↵→for i in range(n1):↵→→L[i] = arr[left + i]↵→for j in range(n2):↵→→R[j] = arr[mid + 1 + j]↵↵→i = 0  # Initial index of first subarray↵→j = 0  # Initial index of second subarray↵→k = left  # Initial index of merged subarray↵↵→while i < n1 and j < n2:↵→→if L[i] <= R[j]:↵→→→arr[k] = L[i]↵→→→i += 1↵→→else:↵→→→arr[k] = R[j]↵→→→j += 1↵→→k += 1↵↵→while i < n1:↵→→arr[k] = L[i]↵→→i += 1↵→→k += 1↵↵→while j < n2:↵→→arr[k] = R[j]↵→→j += 1↵→→k += 1↵↵def merge_sort(arr, left, right):↵→if left < right:↵→→mid = (left + right) // 2↵↵→→merge_sort(arr, left, mid)↵→→merge_sort(arr, mid + 1, right)↵→→merge(arr, left, mid, right)↵↵def print_list(arr):↵→for i in arr:↵→→print(i, end=\" \")↵→print()↵↵if __name__ == \"__main__\":↵→arr = [12, 11, 13, 5, 6, 7]↵→print(\"Given array is\")↵→print_list(arr)↵↵→merge_sort(arr, 0, len(arr) - 1)↵↵→print(\"\\nSorted array is\")↵→print_list(arr)","comments":{"4":"\t# Create temp arrays\r","7":"\t# Copy data to temp arrays L[] and R[]\r","16":"\t# Merge the temp arrays back\r\t# into arr[left..right]\r","25":"\t# Copy the remaining elements of L[],\r\t# if there are any\r","30":"\t# Copy the remaining elements of R[], \r\t# if there are any\r","48":"# Driver code\r"}}},"slink":{"c":{"lines":"struct Node {↵→int data;↵→struct Node* next;↵};↵↵struct Node* newNode(int data) {↵→struct Node* temp =↵→  (struct Node*)malloc(sizeof(struct Node));↵→temp->data = data;↵→temp->next = NULL;↵→return temp;↵}↵↵void traverseLinkedList(struct Node* head)↵{↵→struct Node* current = head;↵↵→while (current != NULL) {↵↵→→printf(\"%d \", current->data);↵↵→→current = current->next;↵→}↵↵→printf(\"\\n\");↵}","comments":{"0":"// Definition of a Node in a singly linked list\r","5":"// Function to create a new Node\r","13":"// Function to traverse and print the elements \r// of the linked list\r","15":"\t// Start from the head of the linked list\r","17":"\t// Traverse the linked list until reaching the end (NULL)\r","19":"\t\t// Print the data of the current node\r","21":"\t\t// Move to the next node\r"}},"py":{"lines":"class Node:↵→def __init__(self, data):↵→→self.data = data↵→→self.next = None↵↵def insert_at_beginning(head, data):↵→new_node = Node(data)↵→new_node.next = head↵→return new_node↵↵def traverse(head):↵→current = head↵→while current:↵→→print(str(current.data) + \" -> \", end=\" \")↵→→current = current.next↵→print(\"None\")↵↵head = None↵head = insert_at_beginning(head, 4)↵head = insert_at_beginning(head, 3)↵head = insert_at_beginning(head, 2)↵head = insert_at_beginning(head, 1)↵↵traverse(head)","comments":{"0":"# Python Program for traversal of Singly Linked list\r","13":"\t\t# Print the current node's data followed by an arrow and space\r","15":"\t# At the end of the list, print None to indicate no further nodes\r","17":"# Singly linked list created and its head stored in a variable named \"head\"\r","23":"# To traverse and print the nodes:\r"}}},"dlink":{"c":{"lines":"#include <stdio.h>↵#include <stdlib.h>↵↵struct Node {↵→int data;↵→struct Node* next;↵→struct Node* prev;↵};↵↵struct Node* createNode(int data) {↵→struct Node* newNode =↵→  (struct Node*)malloc(sizeof(struct Node));↵→newNode->data = data;↵→newNode->next = NULL;↵→newNode->prev = NULL;↵→return newNode;↵}↵↵void forwardTraversal(struct Node* head) {↵↵→struct Node* curr = head;↵↵→while (curr != NULL) {↵↵→→printf(\"%d \", curr->data);↵↵→→curr = curr->next;↵→}↵↵→printf(\"\\n\");↵}↵↵void backwardTraversal(struct Node* tail) {↵↵→struct Node* curr = tail;↵↵→while (curr != NULL) {↵↵→→printf(\"%d \", curr->data);↵↵→→curr = curr->prev;↵→}↵↵→printf(\"\\n\");↵}↵↵int main() {↵↵→struct Node* head = createNode(1);↵→struct Node* second = createNode(2);↵→struct Node* third = createNode(3);↵↵→head->next = second;↵→second->prev = head;↵→second->next = third;↵→third->prev = second;↵↵→printf(\"Forward Traversal:\\n\");↵→forwardTraversal(head);↵↵→printf(\"Backward Traversal:\\n\");↵→backwardTraversal(third);↵↵→free(head);↵→free(second);↵→free(third);↵↵→return 0;↵}","comments":{"3":"// Define the Node structure\r","4":"\t// Data stored in the node\r","5":"\t// Pointer to the next node\r","6":"\t// Pointer to the previous node\r","9":"// Function to create a new node\r","18":"// Function to traverse the doubly linked list \r// in forward direction\r","20":"\t// Start traversal from the head of the list\r","22":"\t// Continue until the current node is not\r\t// null (end of list)\r","24":"\t\t// Output data of the current node\r","26":"\t\t// Move to the next node\r","29":"\t// Print newline after traversal\r","32":"// Function to traverse the doubly linked list \r// in backward direction\r","34":"\t// Start traversal from the tail of the list\r","36":"\t// Continue until the current node is not \r\t// null (end of list)\r","38":"\t\t// Output data of the current node\r","40":"\t\t// Move to the previous node\r","43":"\t// Print newline after traversal\r","48":"\t// Sample usage of the doubly linked list and \r\t// traversal functions\r","63":"\t// Free memory allocated for nodes\r"}},"py":{"lines":"class Node:↵→def __init__(self, data):↵→→self.data = data↵→→self.next = None↵→→self.prev = None↵↵↵def traverse(head):↵→current = head↵→while current:↵→→print(current.data, end=\" <-> \")↵→→current = current.next↵→print(\"None\")↵↵↵def insert_at_beginning(head, data):↵→new_node = Node(data)↵→new_node.next = head↵→if head:↵→→head.prev = new_node↵→return new_node↵↵↵head = None↵head = insert_at_beginning(head, 4)↵head = insert_at_beginning(head, 3)↵head = insert_at_beginning(head, 2)↵head = insert_at_beginning(head, 1)↵↵traverse(head)","comments":{"0":"# Python Program for traversal of a doubly linked list\r","2":"\t\t# Initialize a new node with data, previous, and next pointers\r","8":"\t# Traverse the doubly linked list and print its elements\r","10":"\t  # Print current node's data\r","11":"\t\t# Move to the next node\r","16":"\t# Insert a new node at the beginning of the doubly linked list\r","23":"# Driver Code\r","29":"# To traverse and print the nodes:\r"}}},"queue":{"c":{"lines":"#include <stdbool.h>↵#include <stdio.h>↵#define MAX_SIZE 100↵↵typedef struct {↵→int items[MAX_SIZE];↵→int front;↵→int rear;↵} Queue;↵↵void initializeQueue(Queue* q)↵{↵→q->front = -1;↵→q->rear = 0;↵}↵↵bool isEmpty(Queue* q) { return (q->front == q->rear - 1); }↵↵bool isFull(Queue* q) { return (q->rear == MAX_SIZE); }↵↵void enqueue(Queue* q, int value)↵{↵→if (isFull(q)) {↵→→printf(\"Queue is full\\n\");↵→→return;↵→}↵→q->items[q->rear] = value;↵→q->rear++;↵}↵↵void dequeue(Queue* q)↵{↵→if (isEmpty(q)) {↵→→printf(\"Queue is empty\\n\");↵→→return;↵→}↵→q->front++;↵}↵↵int peek(Queue* q)↵{↵→if (isEmpty(q)) {↵→→printf(\"Queue is empty\\n\");↵→→return -1; // return some default value or handle↵→}↵→return q->items[q->front + 1];↵}↵↵void printQueue(Queue* q)↵{↵→if (isEmpty(q)) {↵→→printf(\"Queue is empty\\n\");↵→→return;↵→}↵↵→printf(\"Current Queue: \");↵→for (int i = q->front + 1; i < q->rear; i++) {↵→→printf(\"%d \", q->items[i]);↵→}↵→printf(\"\\n\");↵}↵↵int main()↵{↵→Queue q;↵→initializeQueue(&q);↵↵→enqueue(&q, 10);↵→printQueue(&q);↵↵→enqueue(&q, 20);↵→printQueue(&q);↵↵→enqueue(&q, 30);↵→printQueue(&q);↵↵→printf(\"Front element: %d\\n\", peek(&q));↵↵→dequeue(&q);↵→printQueue(&q);↵↵→printf(\"Front element after dequeue: %d\\n\", peek(&q));↵↵→return 0;↵}","comments":{"0":"// C Program to demonstrate how to Implement a queue\r","4":"// Defining the Queue structure\r","10":"// Function to initialize the queue\r","16":"// Function to check if the queue is empty\r","18":"// Function to check if the queue is full\r","20":"// Function to add an element to the queue (Enqueue\r// operation)\r","30":"// Function to remove an element from the queue (Dequeue\r// operation)\r","39":"// Function to get the element at the front of the queue\r// (Peek operation)\r","44":"\t\t\t\t   // error differently\r","48":"// Function to print the current queue\r","67":"\t// Enqueue elements\r","76":"\t// Peek front element\r","78":"\t// Dequeue an element\r","81":"\t// Peek front element after dequeue\r"}},"py":{"lines":"class Queue:↵→def __init__(self, q_size):↵→→self.arr = [0] * q_size↵→→self.size = 0↵→→self.capacity = q_size↵→→self.front = 0↵↵→def enqueue(self, x):↵↵→→if self.size == self.capacity:↵→→→return↵↵→→self.arr[self.size] = x↵↵→→self.size += 1↵↵→def dequeue(self):↵↵→→if self.size == 0:↵→→→return↵↵→→for i in range(1, self.size):↵→→→self.arr[i-1] = self.arr[i]↵↵→→self.size -= 1↵↵→def getFront(self):↵↵→→if self.size == 0:↵→→→return -1↵↵→→return self.arr[self.front]↵↵→def display(self):↵↵→→for i in range(self.front, self.size):↵→→→print(self.arr[i], end=\" \")↵→→print()↵↵if __name__ == \"__main__\":↵→q = Queue(4)↵↵→q.enqueue(1)↵→q.enqueue(2)↵→q.enqueue(3)↵→print(q.getFront())↵→q.dequeue()↵→q.enqueue(4)↵→q.display()","comments":{"7":"\t# Function to add an element\r\t# to queue.\r","9":"\t\t# If queue is full\r","14":"\t\t# Increment queue size.\r","16":"\t# Function to pop front \r\t# element from queue.\r","18":"\t\t# If queue is empty \r","21":"\t\t# Shift all the elements \r\t\t# to the left.\r","24":"\t\t# decrement queue size \r","26":"\t# Function which returns \r\t# the front element.\r","28":"\t\t# If queue is empty\r","33":"\t# Function which prints\r\t# the elements of array.\r"}}},"insertionsort":{"c":{"lines":"#include <math.h>↵#include <stdio.h>↵↵void insertionSort(int arr[], int N) {↵↵→for (int i = 1; i < N; i++) {↵→→int key = arr[i];↵→→int j = i - 1;↵↵→→while (j >= 0 && arr[j] > key) {↵→→→arr[j + 1] = arr[j];↵→→→j = j - 1;↵→→}↵↵→→arr[j + 1] = key;↵→}↵}↵↵int main() {↵→int arr[] = { 12, 11, 13, 5, 6 };↵→int N = sizeof(arr) / sizeof(arr[0]);↵↵→printf(\"Unsorted array: \");↵→for (int i = 0; i < N; i++) {↵→→printf(\"%d \", arr[i]);↵→}↵→printf(\"\\n\");↵↵→insertionSort(arr, N);↵↵→printf(\"Sorted array: \");↵→for (int i = 0; i < N; i++) {↵→→printf(\"%d \", arr[i]);↵→}↵→printf(\"\\n\");↵↵→return 0;↵}","comments":{"0":"// C program to implement insertion sort\r","5":"\t// Starting from the second element\r","9":"\t\t// Move elements of arr[0..i-1], that are\r\t\t  // greater than key, to one position to\r\t\t  // the right of their current position\r","14":"\t\t// Move the key to its correct position\r","28":"\t// Calling insertion sort on array arr\r"}},"py":{"lines":"def insertionSort(arr):↵→n = len(arr)  # Get the length of the array↵↵→if n <= 1:↵→→return  # If the array has 0 or 1 element, it is already sorted, so return↵↵→for i in range(1, n):  # Iterate over the array starting from the second element↵→→key = arr[i]  # Store the current element as the key to be inserted in the right position↵→→j = i-1↵→→while j >= 0 and key < arr[j]:  # Move elements greater than key one position ahead↵→→→arr[j+1] = arr[j]  # Shift elements to the right↵→→→j -= 1↵→→arr[j+1] = key  # Insert the key in the correct position↵↵arr = [12, 11, 13, 5, 6]↵insertionSort(arr)↵print(arr)","comments":{"14":"# Sorting the array [12, 11, 13, 5, 6] using insertionSort\r"}}},"stack":{"c":{"lines":"#include <limits.h>↵#include <stdio.h>↵#include <stdlib.h>↵↵struct Stack {↵→int top;↵→unsigned capacity;↵→int* array;↵};↵↵struct Stack* createStack(unsigned capacity)↵{↵→struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));↵→stack->capacity = capacity;↵→stack->top = -1;↵→stack->array = (int*)malloc(stack->capacity * sizeof(int));↵→return stack;↵}↵↵int isFull(struct Stack* stack)↵{↵→return stack->top == stack->capacity - 1;↵}↵↵int isEmpty(struct Stack* stack)↵{↵→return stack->top == -1;↵}↵↵void push(struct Stack* stack, int item)↵{↵→if (isFull(stack))↵→→return;↵→stack->array[++stack->top] = item;↵→printf(\"%d pushed to stack\\n\", item);↵}↵↵int pop(struct Stack* stack)↵{↵→if (isEmpty(stack))↵→→return INT_MIN;↵→return stack->array[stack->top--];↵}↵↵int peek(struct Stack* stack)↵{↵→if (isEmpty(stack))↵→→return INT_MIN;↵→return stack->array[stack->top];↵}↵↵int main()↵{↵→struct Stack* stack = createStack(100);↵↵→push(stack, 10);↵→push(stack, 20);↵→push(stack, 30);↵↵→printf(\"%d popped from stack\\n\", pop(stack));↵↵→return 0;↵}","comments":{"0":"// C program for array implementation of stack \r","4":"// A structure to represent a stack \r","10":"// function to create a stack of given capacity. It initializes size of \r// stack as 0 \r","19":"// Stack is full when top is equal to the last index \r","24":"// Stack is empty when top is equal to -1 \r","29":"// Function to add an item to stack. It increases top by 1 \r","37":"// Function to remove an item from stack. It decreases top by 1 \r","44":"// Function to return the top from stack without removing it \r","51":"// Driver program to test above functions \r"}},"py":{"lines":"↵from sys import maxsize↵↵def createStack():↵→stack = []↵→return stack↵↵def isEmpty(stack):↵→return len(stack) == 0↵↵def push(stack, item):↵→stack.append(item)↵→print(item + \" pushed to stack \")↵↵def pop(stack):↵→if (isEmpty(stack)):↵→→return str(-maxsize -1) # return minus infinite↵↵→return stack.pop()↵↵def peek(stack):↵→if (isEmpty(stack)):↵→→return str(-maxsize -1) # return minus infinite↵→return stack[len(stack) - 1]↵↵stack = createStack()↵push(stack, str(10))↵push(stack, str(20))↵push(stack, str(30))↵print(pop(stack) + \" popped from stack\")","comments":{"0":"# Python program for implementation of stack \r","1":"# import maxsize from sys module \r# Used to return -infinite when stack is empty \r","3":"# Function to create a stack. It initializes size of stack as 0 \r","7":"# Stack is empty when stack size is 0 \r","10":"# Function to add an item to stack. It increases size by 1 \r","14":"# Function to remove an item from stack. It decreases size by 1 \r","20":"# Function to return the top from stack without removing it \r","25":"# Driver program to test above functions     \r"}}}}