{"bubblesort":{"c":{"lines":"#include <stdlib.h>↵#include <stdio.h>↵↵int * create_int_list(const int size) {↵→if (size > 0) {↵→→return (int *) malloc(sizeof(int) * size);↵→}↵→return NULL;↵}↵↵void swap(int * int_list, const int index_other, const int index_chosen) {↵→int temporary = int_list[index_other];↵→int_list[index_other] = int_list[index_chosen];↵→int_list[index_chosen] = temporary;↵}↵↵void bubblesort(int * int_list, const int size) {↵→for (int index_chosen = 0; index_chosen < size; index_chosen++) {↵→→for (int index_other = index_chosen + 1; index_other < size; index_other++) {↵→→→if (int_list[index_other] < int_list[index_chosen]) {↵→→→→swap(int_list, index_other, index_chosen);↵→→→}↵→→}↵→}↵}↵↵int main() {↵→const int size = 5;↵→int * int_list = create_int_list(size);↵→↵→int_list[0] = 6;↵→int_list[1] = -1;↵→int_list[2] = 5;↵→int_list[3] = 9;↵→int_list[4] = 1;↵↵→bubblesort(int_list, size);↵↵→free(int_list);↵}↵","comments":{"3":"/*\r * Memory allocation for the integer list.\r * In this case, we multiply \"sizeof(int)\" by 10 since we want an array with 10 integers!\r * \"(int *)\" is a cast just to ensure that we get a pointer to an integer from whatever malloc returns.\r */\r","4":"\t/* if the size the programmer passes is greater than 0, */\r","5":"\t\t/* \r\t\t * \"sizeof(int)\" returns the number of bytes an integer takes!\r\t\t * We can multiply this value by the programmer's specified size \r\t\t * to allocate a block of memory that's fitted just as they need!\r\t\t */\r","7":"\t/* if we're out here, the programmer gave us a size less than or equal to 0-- just return NULL! */\r","11":"\t/* in order to swap the values, we have to store one of the values elsewhere temporarily! */\r","12":"\t/* then we can move the chosen index's value to the other index! */\r","13":"\t/* ... and then move the old value of the other index into the chosen index! */\r","17":"\t/* \r\t * bubblesort focuses on doing this directly: we can choose an index and then look at the others.\r\t * When we \"choose\" an index, we can look at other indexes and ask the question: is the other index's \r\t * value less than the chosen index's value? If it is less, we can just swap them both!\r\t */\r","19":"\t\t\t/* \r\t\t\t * if the other index's value is less than the chosen index's value,\r\t\t\t * swap the values in the indexes!\r\t\t\t */\r","22":"\t\t\t/* ...and afterwards, continue on! keep going until you've checked every index! */\r","28":"\t/* create an integer array of size 5-- 5 indexes! */\r","30":"\t/* fill out the array... */\r","35":"\t/* int_list is currently: [6, -1, 5, 9, 1] */\r","36":"\t/* sort it from least to greatest via bubblesort! */\r","37":"\t/* int_list is now: [-1, 1, 5, 6, 9] */\r","38":"\t/* be sure to always free the memory you allocate! */\r"}},"py":{"lines":"def bubble_sort(arr):↵  ↵→for n in range(len(arr) - 1, 0, -1):↵→→↵→→swapped = False  ↵↵→→for i in range(n):↵→→→if arr[i] > arr[i + 1]:↵→→→  ↵→→→→arr[i], arr[i + 1] = arr[i + 1], arr[i]↵→→→→↵→→→→swapped = True↵→→↵→→if not swapped:↵→→→break↵↵↵arr = [39, 12, 18, 85, 72, 10, 2, 18]↵print(\"Unsorted list is:\")↵print(arr)↵↵bubble_sort(arr)↵↵print(\"Sorted list is:\")↵print(arr)","comments":{"2":"\t# Outer loop to iterate through the list n times\r","4":"\t\t# Initialize swapped to track if any swaps occur\r","6":"\t\t# Inner loop to compare adjacent elements\r","9":"\t\t\t\t# Swap elements if they are in the wrong order\r","11":"\t\t\t\t# Mark that a swap has occurred\r","13":"\t\t# If no swaps occurred, the list is already sorted\r","17":"# Sample list to be sorted\r"}}},"mergesort":{"c":{"lines":"#include <stdio.h>↵#include <stdlib.h>↵↵void merge(int arr[], int l, int m, int r)↵{↵    int i, j, k;↵    int n1 = m - l + 1;↵    int n2 = r - m;↵↵    int L[n1], R[n2];↵↵    for (i = 0; i < n1; i++)↵        L[i] = arr[l + i];↵    for (j = 0; j < n2; j++)↵        R[j] = arr[m + 1 + j];↵↵    i = 0;↵    j = 0;↵    k = l;↵    while (i < n1 && j < n2) {↵        if (L[i] <= R[j]) {↵            arr[k] = L[i];↵            i++;↵        }↵        else {↵            arr[k] = R[j];↵            j++;↵        }↵        k++;↵    }↵↵    while (i < n1) {↵        arr[k] = L[i];↵        i++;↵        k++;↵    }↵↵    while (j < n2) {↵        arr[k] = R[j];↵        j++;↵        k++;↵    }↵}↵↵void mergeSort(int arr[], int l, int r)↵{↵    if (l < r) {↵        int m = l + (r - l) / 2;↵↵        mergeSort(arr, l, m);↵        mergeSort(arr, m + 1, r);↵↵        merge(arr, l, m, r);↵    }↵}↵↵void printArray(int A[], int size)↵{↵    int i;↵    for (i = 0; i < size; i++)↵        printf(\"%d \", A[i]);↵    printf(\"\\n\");↵}↵↵int main()↵{↵    int arr[] = { 12, 11, 13, 5, 6, 7 };↵    int arr_size = sizeof(arr) / sizeof(arr[0]);↵↵    printf(\"Given array is \\n\");↵    printArray(arr, arr_size);↵↵    mergeSort(arr, 0, arr_size - 1);↵↵    printf(\"\\nSorted array is \\n\");↵    printArray(arr, arr_size);↵    return 0;↵}","comments":{"0":"// C program for Merge Sort\r","3":"// Merges two subarrays of arr[].\r// First subarray is arr[l..m]\r// Second subarray is arr[m+1..r]\r","9":"    // Create temp arrays\r","11":"    // Copy data to temp arrays L[] and R[]\r","16":"    // Merge the temp arrays back into arr[l..r\r","31":"    // Copy the remaining elements of L[],\r    // if there are any\r","37":"    // Copy the remaining elements of R[],\r    // if there are any\r","44":"// l is for left index and r is right index of the\r// sub-array of arr to be sorted\r","49":"        // Sort first and second halves\r","56":"// Function to print an array\r","64":"// Driver code\r"}},"py":{"lines":"def merge(arr, left, mid, right):↵→n1 = mid - left + 1↵→n2 = right - mid↵↵→L = [0] * n1↵→R = [0] * n2↵↵→for i in range(n1):↵→→L[i] = arr[left + i]↵→for j in range(n2):↵→→R[j] = arr[mid + 1 + j]↵↵→i = 0  # Initial index of first subarray↵→j = 0  # Initial index of second subarray↵→k = left  # Initial index of merged subarray↵↵→while i < n1 and j < n2:↵→→if L[i] <= R[j]:↵→→→arr[k] = L[i]↵→→→i += 1↵→→else:↵→→→arr[k] = R[j]↵→→→j += 1↵→→k += 1↵↵→while i < n1:↵→→arr[k] = L[i]↵→→i += 1↵→→k += 1↵↵→while j < n2:↵→→arr[k] = R[j]↵→→j += 1↵→→k += 1↵↵def merge_sort(arr, left, right):↵→if left < right:↵→→mid = (left + right) // 2↵↵→→merge_sort(arr, left, mid)↵→→merge_sort(arr, mid + 1, right)↵→→merge(arr, left, mid, right)↵↵def print_list(arr):↵→for i in arr:↵→→print(i, end=\" \")↵→print()↵↵if __name__ == \"__main__\":↵→arr = [12, 11, 13, 5, 6, 7]↵→print(\"Given array is\")↵→print_list(arr)↵↵→merge_sort(arr, 0, len(arr) - 1)↵↵→print(\"\\nSorted array is\")↵→print_list(arr)","comments":{"4":"\t# Create temp arrays\r","7":"\t# Copy data to temp arrays L[] and R[]\r","16":"\t# Merge the temp arrays back\r\t# into arr[left..right]\r","25":"\t# Copy the remaining elements of L[],\r\t# if there are any\r","30":"\t# Copy the remaining elements of R[], \r\t# if there are any\r","48":"# Driver code\r"}}},"slink":{"c":{"lines":"struct Node {↵    int data;          ↵    struct Node* next;↵};↵↵struct Node* newNode(int data) {↵    struct Node* temp = ↵      (struct Node*)malloc(sizeof(struct Node));↵    temp->data = data;↵    temp->next = NULL;↵    return temp;↵}↵↵void traverseLinkedList(struct Node* head)↵{↵    struct Node* current = head;↵↵    while (current != NULL) {↵↵        printf(\"%d \", current->data);↵↵        current = current->next;↵    }↵↵    printf(\"\\n\");↵}","comments":{"0":"// Definition of a Node in a singly linked list\r","5":"// Function to create a new Node\r","13":"// Function to traverse and print the elements \r// of the linked list\r","15":"    // Start from the head of the linked list\r","17":"    // Traverse the linked list until reaching the end (NULL)\r","19":"        // Print the data of the current node\r","21":"        // Move to the next node\r"}},"py":{"lines":"class Node:↵→def __init__(self, data):↵→→self.data = data↵→→self.next = None↵↵def insert_at_beginning(head, data):↵→new_node = Node(data)↵→new_node.next = head↵→return new_node↵→→↵def traverse(head):↵→current = head↵→while current:↵→→print(str(current.data) + \" -> \", end=\" \")↵→→current = current.next↵→print(\"None\")↵↵head = None↵head = insert_at_beginning(head, 4)↵head = insert_at_beginning(head, 3)↵head = insert_at_beginning(head, 2)↵head = insert_at_beginning(head, 1)↵↵traverse(head)","comments":{"0":"# Python Program for traversal of Singly Linked list\r","13":"\t\t# Print the current node's data followed by an arrow and space\r","15":"\t# At the end of the list, print None to indicate no further nodes\r","17":"# Singly linked list created and its head stored in a variable named \"head\"\r","23":"# To traverse and print the nodes:\r"}}},"dlink":{"c":{"lines":"#include <stdio.h>↵#include <stdlib.h>↵↵struct Node {↵    int data; // Data stored in the node↵    struct Node* next; // Pointer to the next node↵    struct Node* prev; // Pointer to the previous node↵};↵↵struct Node* createNode(int data) {↵    struct Node* newNode = ↵      (struct Node*)malloc(sizeof(struct Node));↵    newNode->data = data;↵    newNode->next = NULL;↵    newNode->prev = NULL;↵    return newNode;↵}↵↵void forwardTraversal(struct Node* head) {↵  ↵    struct Node* curr = head;↵↵    while (curr != NULL) {↵      ↵        printf(\"%d \", curr->data);↵      ↵        curr = curr->next;↵    }↵↵    printf(\"\\n\");↵}↵↵void backwardTraversal(struct Node* tail) {↵  ↵    struct Node* curr = tail;↵↵    while (curr != NULL) {↵      ↵        printf(\"%d \", curr->data);↵      ↵        curr = curr->prev;↵    }↵↵    printf(\"\\n\");↵}↵↵int main() {↵  ↵    struct Node* head = createNode(1);↵    struct Node* second = createNode(2);↵    struct Node* third = createNode(3);↵↵    head->next = second;↵    second->prev = head;↵    second->next = third;↵    third->prev = second;↵↵    printf(\"Forward Traversal:\\n\");↵    forwardTraversal(head);↵↵    printf(\"Backward Traversal:\\n\");↵    backwardTraversal(third);↵↵    free(head);↵    free(second);↵    free(third);↵↵    return 0;↵}","comments":{"3":"// Define the Node structure\r","9":"// Function to create a new node\r","18":"// Function to traverse the doubly linked list \r// in forward direction\r","20":"    // Start traversal from the head of the list\r","22":"    // Continue until the current node is not\r    // null (end of list)\r","24":"        // Output data of the current node\r","26":"        // Move to the next node\r","29":"    // Print newline after traversal\r","32":"// Function to traverse the doubly linked list \r// in backward direction\r","34":"    // Start traversal from the tail of the list\r","36":"    // Continue until the current node is not \r    // null (end of list)\r","38":"        // Output data of the current node\r","40":"        // Move to the previous node\r","43":"    // Print newline after traversal\r","48":"    // Sample usage of the doubly linked list and \r    // traversal functions\r","63":"    // Free memory allocated for nodes\r"}},"py":{"lines":"class Node:↵→def __init__(self, data):↵→→self.data = data↵→→self.next = None↵→→self.prev = None↵↵↵def traverse(head):↵→current = head↵→while current:↵→→print(current.data, end=\" <-> \")↵→→current = current.next↵→print(\"None\")↵↵↵def insert_at_beginning(head, data):↵→new_node = Node(data)↵→new_node.next = head↵→if head:↵→→head.prev = new_node↵→return new_node↵↵↵head = None↵head = insert_at_beginning(head, 4)↵head = insert_at_beginning(head, 3)↵head = insert_at_beginning(head, 2)↵head = insert_at_beginning(head, 1)↵↵traverse(head)","comments":{"0":"# Python Program for traversal of a doubly linked list\r","2":"\t\t# Initialize a new node with data, previous, and next pointers\r","8":"\t# Traverse the doubly linked list and print its elements\r","10":"\t  # Print current node's data\r","11":"\t\t# Move to the next node\r","16":"\t# Insert a new node at the beginning of the doubly linked list\r","23":"# Driver Code\r","29":"# To traverse and print the nodes:\r"}}},"queue":{"c":{"lines":"#include <stdbool.h>↵#include <stdio.h>↵#define MAX_SIZE 100↵↵typedef struct {↵    int items[MAX_SIZE];↵    int front;↵    int rear;↵} Queue;↵↵void initializeQueue(Queue* q)↵{↵    q->front = -1;↵    q->rear = 0;↵}↵↵bool isEmpty(Queue* q) { return (q->front == q->rear - 1); }↵↵bool isFull(Queue* q) { return (q->rear == MAX_SIZE); }↵↵void enqueue(Queue* q, int value)↵{↵    if (isFull(q)) {↵        printf(\"Queue is full\\n\");↵        return;↵    }↵    q->items[q->rear] = value;↵    q->rear++;↵}↵↵void dequeue(Queue* q)↵{↵    if (isEmpty(q)) {↵        printf(\"Queue is empty\\n\");↵        return;↵    }↵    q->front++;↵}↵↵int peek(Queue* q)↵{↵    if (isEmpty(q)) {↵        printf(\"Queue is empty\\n\");↵        return -1; // return some default value or handle↵    }↵    return q->items[q->front + 1];↵}↵↵void printQueue(Queue* q)↵{↵    if (isEmpty(q)) {↵        printf(\"Queue is empty\\n\");↵        return;↵    }↵↵    printf(\"Current Queue: \");↵    for (int i = q->front + 1; i < q->rear; i++) {↵        printf(\"%d \", q->items[i]);↵    }↵    printf(\"\\n\");↵}↵↵int main()↵{↵    Queue q;↵    initializeQueue(&q);↵↵    enqueue(&q, 10);↵    printQueue(&q);↵↵    enqueue(&q, 20);↵    printQueue(&q);↵↵    enqueue(&q, 30);↵    printQueue(&q);↵↵    printf(\"Front element: %d\\n\", peek(&q));↵↵    dequeue(&q);↵    printQueue(&q);↵↵    printf(\"Front element after dequeue: %d\\n\", peek(&q));↵↵    return 0;↵}","comments":{"0":"// C Program to demonstrate how to Implement a queue\r","4":"// Defining the Queue structure\r","10":"// Function to initialize the queue\r","16":"// Function to check if the queue is empty\r","18":"// Function to check if the queue is full\r","20":"// Function to add an element to the queue (Enqueue\r// operation)\r","30":"// Function to remove an element from the queue (Dequeue\r// operation)\r","39":"// Function to get the element at the front of the queue\r// (Peek operation)\r","44":"                   // error differently\r","48":"// Function to print the current queue\r","67":"    // Enqueue elements\r","76":"    // Peek front element\r","78":"    // Dequeue an element\r","81":"    // Peek front element after dequeue\r"}},"py":{"lines":"class Queue:↵→def __init__(self, q_size):↵→→self.arr = [0] * q_size↵→→self.size = 0↵→→self.capacity = q_size↵→→self.front = 0↵→↵→def enqueue(self, x):↵→→↵→→if self.size == self.capacity:↵→→→return↵→→↵→→self.arr[self.size] = x↵→→↵→→self.size += 1↵→↵→def dequeue(self):↵→→↵→→if self.size == 0:↵→→→return↵→→↵→→for i in range(1, self.size):↵→→→self.arr[i-1] = self.arr[i]↵→→↵→→self.size -= 1↵→↵→def getFront(self):↵→→↵→→if self.size == 0:↵→→→return -1↵→→↵→→return self.arr[self.front]↵→↵→def display(self):↵→→↵→→for i in range(self.front, self.size):↵→→→print(self.arr[i], end=\" \")↵→→print()↵↵if __name__ == \"__main__\":↵→q = Queue(4)↵→↵→q.enqueue(1)↵→q.enqueue(2)↵→q.enqueue(3)↵→print(q.getFront())↵→q.dequeue()↵→q.enqueue(4)↵→q.display()","comments":{"7":"\t# Function to add an element\r\t# to queue.\r","9":"\t\t# If queue is full\r","14":"\t\t# Increment queue size.\r","16":"\t# Function to pop front \r\t# element from queue.\r","18":"\t\t# If queue is empty \r","21":"\t\t# Shift all the elements \r\t\t# to the left.\r","24":"\t\t# decrement queue size \r","26":"\t# Function which returns \r\t# the front element.\r","28":"\t\t# If queue is empty\r","33":"\t# Function which prints\r\t# the elements of array.\r"}}},"insertionsort":{"c":{"lines":"#include <math.h>↵#include <stdio.h>↵↵void insertionSort(int arr[], int N) {↵↵    for (int i = 1; i < N; i++) {↵        int key = arr[i];↵        int j = i - 1;↵↵        while (j >= 0 && arr[j] > key) {↵            arr[j + 1] = arr[j];↵            j = j - 1;↵        }↵↵        arr[j + 1] = key;↵    }↵}↵↵int main() {↵    int arr[] = { 12, 11, 13, 5, 6 };↵    int N = sizeof(arr) / sizeof(arr[0]);↵↵    printf(\"Unsorted array: \");↵    for (int i = 0; i < N; i++) {↵        printf(\"%d \", arr[i]);↵    }↵    printf(\"\\n\");↵↵    insertionSort(arr, N);↵↵    printf(\"Sorted array: \");↵    for (int i = 0; i < N; i++) {↵        printf(\"%d \", arr[i]);↵    }↵    printf(\"\\n\");↵↵    return 0;↵}","comments":{"0":"// C program to implement insertion sort\r","5":"    // Starting from the second element\r","9":"        // Move elements of arr[0..i-1], that are\r          // greater than key, to one position to\r          // the right of their current position\r","14":"        // Move the key to its correct position\r","28":"    // Calling insertion sort on array arr\r"}},"py":{"lines":"def insertionSort(arr):↵→n = len(arr)  # Get the length of the array↵→  ↵→if n <= 1:↵→→return  # If the array has 0 or 1 element, it is already sorted, so return↵ ↵→for i in range(1, n):  # Iterate over the array starting from the second element↵→→key = arr[i]  # Store the current element as the key to be inserted in the right position↵→→j = i-1↵→→while j >= 0 and key < arr[j]:  # Move elements greater than key one position ahead↵→→→arr[j+1] = arr[j]  # Shift elements to the right↵→→→j -= 1↵→→arr[j+1] = key  # Insert the key in the correct position↵  ↵arr = [12, 11, 13, 5, 6]↵insertionSort(arr)↵print(arr)","comments":{"14":"# Sorting the array [12, 11, 13, 5, 6] using insertionSort\r"}}},"stack":{"c":{"lines":"#include <limits.h> ↵#include <stdio.h> ↵#include <stdlib.h> ↵↵struct Stack { ↵    int top; ↵    unsigned capacity; ↵    int* array; ↵}; ↵↵struct Stack* createStack(unsigned capacity) ↵{ ↵    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack)); ↵    stack->capacity = capacity; ↵    stack->top = -1; ↵    stack->array = (int*)malloc(stack->capacity * sizeof(int)); ↵    return stack; ↵} ↵↵int isFull(struct Stack* stack) ↵{ ↵    return stack->top == stack->capacity - 1; ↵} ↵↵int isEmpty(struct Stack* stack) ↵{ ↵    return stack->top == -1; ↵} ↵↵void push(struct Stack* stack, int item) ↵{ ↵    if (isFull(stack)) ↵        return; ↵    stack->array[++stack->top] = item; ↵    printf(\"%d pushed to stack\\n\", item); ↵} ↵↵int pop(struct Stack* stack) ↵{ ↵    if (isEmpty(stack)) ↵        return INT_MIN; ↵    return stack->array[stack->top--]; ↵} ↵↵int peek(struct Stack* stack) ↵{ ↵    if (isEmpty(stack)) ↵        return INT_MIN; ↵    return stack->array[stack->top]; ↵} ↵↵int main() ↵{ ↵    struct Stack* stack = createStack(100); ↵↵    push(stack, 10); ↵    push(stack, 20); ↵    push(stack, 30); ↵↵    printf(\"%d popped from stack\\n\", pop(stack)); ↵↵    return 0; ↵}","comments":{"0":"// C program for array implementation of stack \r","4":"// A structure to represent a stack \r","10":"// function to create a stack of given capacity. It initializes size of \r// stack as 0 \r","19":"// Stack is full when top is equal to the last index \r","24":"// Stack is empty when top is equal to -1 \r","29":"// Function to add an item to stack. It increases top by 1 \r","37":"// Function to remove an item from stack. It decreases top by 1 \r","44":"// Function to return the top from stack without removing it \r","51":"// Driver program to test above functions \r"}},"py":{"lines":"↵from sys import maxsize ↵↵def createStack(): ↵→stack = [] ↵→return stack ↵↵def isEmpty(stack): ↵→return len(stack) == 0↵↵def push(stack, item): ↵→stack.append(item) ↵→print(item + \" pushed to stack \") ↵→↵def pop(stack): ↵→if (isEmpty(stack)): ↵→→return str(-maxsize -1) # return minus infinite ↵→↵→return stack.pop() ↵↵def peek(stack): ↵→if (isEmpty(stack)): ↵→→return str(-maxsize -1) # return minus infinite ↵→return stack[len(stack) - 1] ↵↵stack = createStack() ↵push(stack, str(10)) ↵push(stack, str(20)) ↵push(stack, str(30)) ↵print(pop(stack) + \" popped from stack\")","comments":{"0":"# Python program for implementation of stack \r","1":"# import maxsize from sys module \r# Used to return -infinite when stack is empty \r","3":"# Function to create a stack. It initializes size of stack as 0 \r","7":"# Stack is empty when stack size is 0 \r","10":"# Function to add an item to stack. It increases size by 1 \r","14":"# Function to remove an item from stack. It decreases size by 1 \r","20":"# Function to return the top from stack without removing it \r","25":"# Driver program to test above functions     \r"}}}}